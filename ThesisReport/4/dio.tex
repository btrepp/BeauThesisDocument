
%: ----------------------- contents from here ------------------------

\section{Arduino Digital Input Module}
\label{sec:arduino}

The car has access to many physical inputs that would be useful to monitor and record. Variables such as the state of the air-conditioning or the radio are useful aspects to monitor. These are currently exposed via bare wires inside the vehicle. As these signals are simple digital logic, they need a way to interface with the controller in order to be used in the system.

Previously the in-built FPGA on the Eye-bot was used to accomplish this end \cite{thesis_varma}. This method requires complex cabling to the inside of the Eye-bot. Use of the FPGA also requires special code to be written to interface with the FPGA, which will be different for different kinds of FPGA devices. This makes maintaining this design difficult, and ties the code in with the specific Eye-bot it was developed for.

Investigation was done into a top16 digital input and output module. This module has 8 digital input lines, and 8 digital output lines. This allows for a total of 8 inputs to be read. While this would be enough to satisfy the input variables, it suffers from some drawbacks. This board was found to use an FTDI chip for usb serial communication. This chip appears as a serial port when the correct drivers are present. Sadly the FTDI drivers for the older Linux kernel were not stable, and it was not possible to use this board in the system.

As the current methods were unsuitable to fulfill this role, a new digital interface system was developed in order to satisfy the requirements needed. This new board would have digital inputs, analogue voltage inputs, and be able to read other signals generated by the car.

\subsection{Speedometer and Tachometer}

A desired feature would be to record more complicated signals from the car, such as the current speed. While the GPS can provide speed readings, a more accurate source of speed data is available. This source is the cars built-in speedometer. The speedometer and tachometer use hall effect sensors in order to read the rotational rate of the gearbox and motor respectively. 

\figuremacro{speedvsfrequency}{Speed (km/h) vs Frequency (Hz)}{}
\figuremacro{rpmvsfrequency}{RPM vs Frequency (Hz)}{}

Figures \ref{speedvsfrequency} and \ref{rpmvsfrequency} show the output on the in-built dash in response to various pulse train frequencies. Both these graphs show that the relationship between the frequency and desired variable are highly linear. Thus it is possible to count the amount of pulses that have transpired and perform a calculation in order to determine the cars current speed.

\subsection{Hardware}

The hardware used to accomplish this task is an Arduino Uno compatible board. This board provides 14 Digital IO pins and 6 Analogue Input pins \cite{arduinospecs}. The Atmega chip inside the board also has inbuilt timers, which can be used to implement the frequency component of the requirements. The board is quite small in size, and only needs 5v to run. Figure \ref{ArduinoUno} shows the Arduino Uno board.

\figuremacroW{ArduinoUno}{Arduino Uno}{}{0.5}

\subsection{ Drivers}

One advantage of the Arduino Uno board over other Arduino boards is that it implements the cdc-acm device drivers that were used in section \ref{sec:gpsdrivers}. The fixes to the drivers implemented previously allow the Arduino Uno to work with the system without any hassle. 

\subsection {Design}

\subsubsection{Arduino}

The program designed for the Arduino uses the internal interrupts of the Arduino in order to keep track of time and the amount of pulse that have occurred. The Arduino contains an ATmega328 \cite{arduinospecs}. This chip contains internal circuitry that is able to count the number of pulses independently of the current system clock. There are two pins available on the micro-controller to facilitate this functionality, and two frequencies the system is interested in recording.

\begin{table}
\begin{center}
    \begin{tabular}{|l|l|}
        \hline
        Property & Value \\ \hline
        Baud Rate    & 115200 \\
        Data Bits    & 8    \\ 
        Stop Bits    & 1    \\ 
        Parity       & None \\ 
        Flow Control & None \\
        \hline
    \end{tabular}
	\caption{Connection settings for Arduino}
\end{center}
\end{table}

The main logic of the Arduino program is fired in an interrupt that fires at a frequency of 125Hz. This interrupt checks the overflow of the 8 bit counter, and stores the result so it can be used later on in the calculation. This allows the program to work with larger numbers than a 8 bit byte can contain. Every 125 cycles of this interrupt, or every one second, the system calculates the number of pulses that have occurred since the last second, and stores it in a different memory location. The program also sets a flag inside the micro-controller, signaling that the data is ready to be sent via a serial link.

When the serial link is signaled, it will read all the digital inputs and analogue inputs as well as the calculated pulses, and transmit them to the device on the other end. As this is a serial stream, it must have some values that are reserved in order to synchronize the data stream. The same method as used in section \ref{sec:expertprotocol}. This uses the same header byte (0xFF) and allows for 7 bits of data to be transmitted per byte. Rather than sending multiple messages, the Arduino sends everything in one message, that is transmitted at 1Hz.

\begin{table}
    \begin{tabular}{*{7}{|l}|}
        \hline
        Byte 1 & Byte 2 & Byte 3 & Byte 4 & Byte 5 & Byte 6  & Byte 7 \\ \hline \hline
        Header & Count & 7 Bits DIO & 5 bits DIO & Analog0 MSB  & Analog0 LSB & Analog 1 MSB  \\ 
        \hline
    \end{tabular}
 \begin{tabular}{*{8}{|l}|}
        \hline
        Byte 8 & Byte 9 & Byte 10 & Byte 11 & Byte 12 & Byte 13 & Byte 14 & Byte 15\\ \hline \hline
       Analog 1 LSB & \multicolumn{4}{|c|}{Frequency 0} & \multicolumn{3}{|c|}{Frequency 1} \\
        \hline
    \end{tabular}
\begin{tabular}{*{8}{|l}|}
        \hline
         Byte 16 & Byte 17 & Byte 18 & Byte 19 & Byte 20 & Byte 21 & Byte 22 \\ \hline \hline
        \multicolumn{1}{|c|}{Frequency 1} & \multicolumn{6}{|c|}{Reserved} & Trailer \\
        \hline
    \end{tabular}
	\caption{Network protocol for the distributed system}
	\label{tab:networkprotocol}
\end{table}

\subsubsection{Host side}

On the host side, the program functions similarly to that of the GPS program, such as in Figure \ref{gpsflowchart}. This module of course, will not set the system date, but otherwise they perform similarly, attempting to read as much data as possible into a buffer, and then finding the correct section to synchronize on.







% ---------------------------------------------------------------------------
%: ----------------------- end of thesis sub-document ------------------------
% ---------------------------------------------------------------------------

