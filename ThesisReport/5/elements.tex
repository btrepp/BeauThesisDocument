\section{Elements}

The windowing toolkit consists of pre-made classes that the are either used directly, such as the digit display element, or are inherited from, such as the base or runnable classes. Figure \ref{uiframework3} shows the classes developed in the toolkit.

\figuremacro{uiframework3}{UML diagram of the window toolkit}{}

\subsection{UIElement}

The UIElement is the most basic class definition in the toolkit. It is an abstract class that can never be instantiated. Its purpose is to define methods for interacting with the screen and other objects. It also provides default functionality for most methods, this allows all the classes that inherit from it to function the same way.

\subsubsection{addChild()}

An important definition of the UIElement class, is that it may contain any number of other UIElement classes inside it. To add another UIElement class the method addChild() is called. This stores the child element inside a C++ vector whose length is only limited by the amount of ram inside the machine. The advantage of this is that actions can be performed on a UIElement and all it's children. If a element needs to be drawn, all it's children will be drawn too or if an element is disabled, all it's children will be disabled too.

\subsubsection{draw()}

 The most important method of the UIElement class is the draw method.  This method definition is not implemented in the UIElement class, it is defined a virtual abstract method. All classes that can be instantiated must implement this function call. The purpose of this function call is to allow the user to specify the low level commands that are used to display this element. This can include drawing lines, squares, or setting individual pixels. This method should be implemented by the programmer, but should only ever be called by the mechanics of the toolkit. The developed of the user interface should never directly call this method.

\subsubsection{enqueueDraw()}

enqueueDraw() is called whenever the system, or the programmer, wants to trigger a refresh of the screen. This will signal the toolkit that a redraw should be prepared. The purpose of this method is two-fold. Firstly it allows the toolkit to perform optimizations of the draw function in order to maximize speed (see \ref{Redrawing the Screen}). Secondly it's implementation has O(1) complexity. This means that the call to enqueueDraw() completes in constant time. This is used for performance reasons, as whatever thread has called enqueueDraw(), will not need to wait for the screen to be redrawed, it will return instantly. The draw will be scheduled to occur some time after enqueueDraw() is called. By default this method will also call the enqueueDraw() method of all it's children, allowing entire sections of the display to be redrawn using one function call.

\subsubsection{animate()}
TODO

\subsubsection{setActive()}

A property that is required of any draw-able object inside the toolkit is whether it is current being displayed to the user. This property allows elements to exist in the machines memory, but only be draw if they are current being displayed. To manipulate this property, the method setActive() is called. This method allows the state to be set to either true or false, meaning that the object will be drawn or not drawn respectively. If the active state is false, calls to enqueueDraw() will be processed, but the call to the draw() function will be skipped. Thus individual elements of the display can be hidden at will. This method will also call the setActive() method of all the children of this element. Thus allowing sections of the display to be hidden with one function call.

\subsubsection{isActive()}

This method will return the current state of the element. This is used to check whether the current element is being drawn or not. This method is called internally by the screen drawing mechanics. It can also be used in order to check whether the element is being displayed, and perform different tasks if it is not being displayed.

\subsection{base}

The base element represents the panels or windows that are being displayed to the user. An important property of the base element is that it is defined to occupy the whole screen. This element will draw the entire width of the screen, which will clear any old draws that may still be present. Another extended property of the base element is that it maintains a list of all the other base elements that are present. This is used in order to allow for global navigation buttons. Rather than layout buttons in the same location on every screen, a button can be added as a global button. This will ensure that it appears on all the screens present in the list. This allows the buttons and their location on the screen to be defined once, making the final program more stable and simpler to understand.
For further discussion on the button element see \ref{sec:Button}.
The base class itself is abstract, it cannot be instansiated. There is no way to display a "default" base element. In order to build a panel, the panel must inherit from the base element, and implement at minimum the abstract function getButton().

\subsubsection{base()}

The constructor for this class takes a single argument. This argument is a boolean value indiciating whether this panel will display global buttons or not. By default this option is set to true, though it can be easily overriden when a new class is inheriting from this one. This optional argument allows a panel to forego global buttons. This is used in the case when the developed only wishes to display a simpler panel, or when the current set of global buttons would appear in-appropriately on this panel.

\subsubsection{draw()}

This class implements a rudimentary version of the draw method. This specifies a default display for each fullscreen panel the user will view. The reasons for this functionality are two-fold. Firstly, it allows a common backdrop to be defined for each screen. This keeps a sense of consitency while navigating, as the background will always be similar. It is also useful in speeding up development, as having a default state for a panel is useful for prototyping and implementing new panels. The second reason a default is specified is to remove any elements that were present on the previous screen. Even though buttons and UIelements may not be active anymore, pixels may still be set corresponding to their images. These pixels may have last been refreshed a long time ago. They will remain in the framebuffer until they are overwritten by a new set of image data. As the a base panel is defined as occupying the whole screen, it will replace and UIElements that may already exist on the screen, thus removing them from being visible. As the instance of this base class with be enqueued onto the drawing queue first, all it's child elements will still be drawn correctly.

\subsubsection{getButton()}

In order to transition to a panel, an action must be undertaken by either the user or the system. The most common way of transisitioning would be when the user wants to display a different screen. Typically this would occur by the use of pressing buttons. This is why any base panel must implement the getButton() function. This function returns a button object that contains the image data to display for this button, and the action to undertake when the button is pressed. This action will typically be a call to the activate() function of the panel, though other actions can be called before the call to activate().

\subsubsection{addButton()}

A common element that will be placed on any panel is a button element. This is the basic way in which the user navigates. A button element itself is a child element of the panel it is contained in, it needs to be drawn when the panel is drawn. A button will also have extra functionality than just being drawn, namely, it can be pressed by the user. As the existing addChild() function only adds the element to the list of child elements to be drawn, an extra method was developed to add buttons to a panel. This method is the addButton method. This method adds the button element to the list of children, but also registers the button element as an interactable object. Internally this is achieved by adding the button to a list that contains only buttons. This list is ordered in the order that the buttons were added to the panel. Maintain this list is important in order to translate the lower level screen interactions into finding which button was pressed see \ref{button_thread}.

\subsubsection{addGlobalButton()}

Mentioned earlier was the use of global buttons, which are buttons that will appear on every class that inherits from base. In order to distinguish between buttons that are added to every base panel and buttons that are added only to the current base panel, the addGlobalButton() function was developed. This method is declared statically and does not need to be called on an instance of a base class, however it does need at least one instance to have been created for it's effects to be observable. In it's simplest form, this method iterates over the list of base elements, and calls the addButton() method on each base using the supplied button argument. This allows the same button to appear on multiple screens, due to the fact that it is the exact same object, it will perform the exact same action and be laid out in the exact same place on each screen.

\subsubsection{refreshTouchMap()}

This method is an internal method to the framework, and should not need to be called by the developer. It is responsible for setting up the touch screen in the lower level libraries. It takes the list of buttons that has been built by calling addButton() and registers each button and the region the button exists on with the touch drivers. This abstracts any interaction or understanding of how the touch screen mechanics away from the developer. This function will be called whenever activate is called, thus setting up the framework to respond to actions on the buttons that exist on the current panel. It will also clear the previously registered buttons, so they cannot be clicked while the system is displaying the new panel.

\subsubsection{buttonPressed()}
\label{sec:base:butpress}
The buttonPressed() method defines what happens when the user presses a button. This method is implemented in the base class definition in a way that it should never need to be overwritten in any classes inheriting from the base class. This method takes the position in the list of buttons that is pressed and performs the actions that occur when the button is pressed. The runnable abstract class allows any action to be coded and run by this method see \ref{sec:runnable}. This method also performs things like animating the buttons. In order to provide instant feedback to the user pressing a button, the framework will invert the colour of the button. After a short while, the button will turn back to it's previous state, and the buttons action will be performed. This small animation provides instant feedback that the user has pressed the button, and results in a much more enjoyable user experience. Delaying the action also has another advantage. By waiting a short time between running the action, which is usually the display of a different base panel, the framework is able to remove and duplicate keypresses that may occur. This prevents the user from pressing a button to transisition into a panel, and then immediately pressing a button in the new panel which they did not intend to press.

\subsubsection{activate()}
\label{sec:activate}

The activate method is defined in the base class. It can be overwritten in classes that inherit from the base class, though any class implementing different functionality should call the base classes activate() method as well. This method's main responsibility is to display or 'activate' the panel that it is called upon, and to translate the touch driver information into button presses. The default functionality of this method, is to call enqueueDraw() first. This will display the current panel on the screen. Next it will call refreshTouchMap(), to register the active buttons to the framework. Once the panel has been setup, this method will then block and await input from the user via screen events. Thus this method should only ever be called in the thread that is responsible for controlling the button presses. A apparent downside to this is that there is no easy to for the developer to change the active panel inside a different thread, it is certainly possible to change the active panel though it is more difficult than changing in response to user interaction. On the other hand, this limitation is actually advantageous from a user friendliness standpoint. As the screen will only change from different base panels in response to actions performed by the user, it is easier for them to mentally link actions they have performed into re-actions displayed by the device. This specification means that the panels won't transisition by themselves, leading to a much simpler and easier to understand user interface. 

This method also allows animations to be specified. By supplying an argument defining the type of screen transition to use, activate method will perform the actions necessary to animate the transisition between the previous panel and this one. These transisitions are implemented inside the screen driver, and include sliding the screen in and out. For performance reasons, the default transistion is an in-place swap, which is the most efficient in respect to CPU time.

When this method finishes it returns the next action to run. This could either be a class that runs the next panel, or some other action to be performed when this panel is not longer being displayed.

\subsection{Popup}

No user interface is complete without popup windows. These are smaller windows that overlay the existing panel. A popup can be positioned anywhere on the screen, and have any width and size, making it a flexible element for displaying information. The popup window will prevent any interaction with the panel they are sitting on top of. This is defined as a modal behaviour \cite{modal}. The reason the popups will only implement modal interfaces is due to the fact that there is no way for the user to manipulate the position of the dialog box. This was done to simplify the user interface, and make it easier to understand. By default a popup will include a close button, so any new popup will always be able to close and return to the normal operation of the panel. Other buttons must be added by the developer. 

\subsubsection{popup()}

The constructor to the popup takes arguments in the form of the size and position of the popup, and an action to be performed when the popup closes. The last argument is a runnable object that will be called when the popup is closed. This allows actions to be scheduled in between the popup dissapearing, and the previous panel taking focus. This flexibility can be used to trigger screen refresh events, or to flush a file to the disk, or even make another panel take focus. The popup class is a child of the base class, and the runnable class.

\subsubsection{buildUI()}

Due to the way C++ calls constructors, a method buildUI has been created in order to over-ride the default button layout. Any class that inherits from another class will call the superclasses constructor. This is a problem if the child class does not wish to use the default exit button provided. To overcome this, the elements inside the popup are laid out when buildUI() is called. This method is called after the popup has been fully constructed. Due to polymorphism, the method will always call the implementation of the child class. This allows the child class to completely override the default layout.

The method has returns a pointer to the class it was called on. This is done to allow the object to be constructed and the layout generated in one line of code, and still return a pointer to the popup object.

\subsubsection{run()}

The popup class implements the runnable abstract class by default. This allows the popup to be passed as a runnable object. This run action performs the neccesary steps in order to activate the popup and display it on the screen. The advantage of this is that a popup can be passed as an argument to the button class, meaning that when the button is pressed the popup will be shown. This results in very simple and easy to read code.

\subsubsection{getButton()}

This method exists because the popup inherits from the base class. It allows the popup to specify a button element that should be used to display the popup. This button element will usually contain a runnable class that activates the popup. This method can return null if there is no button for this popup.

\subsubsection{activate()}

This method is inherited from the base class. See section \ref{sec:activate} for more information.


\subsection{runnable}
\label{sec:runnable}

The runnable class is an abstract class which is used to allow the developer using the toolkit to run actions inside the toolkit. By using polymorphism, the toolkit is able to call methods on classes which were not programmed or compiled with the toolkit. This runnable aspect is used in order to 'run' various aspects of the user interface. For instance, the base class's activate function must return a pointer to a runnable class. This is used to define what happens when the panel is no longer active. Runnable classes are also used extensively by the button system. A button must contain a runnable class. This class will be run when the button is pressed. Thus allowing any code to run whenever a button is pressed by the user. 

\subsubsection{isScreenChange}

A property used in the runnable class is whether this action is triggering a screen change or not. This property is set to true by default. If this property is to, the previous base panel that called this action will have it's active property set to false. This suppresses the last screen from being changed, so the runnable action does not need to know where it was called from. If this property is set to false, the previous panel will not be flagged as inactive. This is used whenever an action is updating a element on the user interface, and does only wants to trigger a redraw of the element that changed. The previous panel will remain active, and will resume listening to touch events when the runnable action is finished.

\subsubsection{run()}

This is the abstract method that must be implemented in any class inheriting from the runnable class. It is called by the framework in order to run developer specified actions. Any code inside this method is run by the thread that controls the button interactions. This means that whatever is inside this method will block the touchscreen until it has completed, though this method is able to interact with the touch screen and read of events itself. This is a useful property, as while the system is performing some action, the user will be prevented from transitioning the screen, or running another action. 

\subsection{Button}
\label{sec:button}

The button class is a fully implemented class in the framework. The developer using the framework does not need to inherit from this class in order to use it's functionality, though they are able to if they desire more control over the way buttons behave. This element is a object representation of a button, and contains all the information required to use the button in the framework. It stores information pertaining to the position, size, state, image and action to be performed when this button is pressed. This allows the framework to lay the button out and display it to the user, and perform actions when the button is pressed. The thumbnail is able to exist as a simple RGB based image, or an alpha enabled RGBA image see \ref{alpha}. The information stored in this object is also used to correctly set up the touch drivers in order to correctly identify when the button is pressed.

\subsubsection{button()}

The constructor of this button requires two parts of information, the action to run when the button is pressed and the image data that will represent this button on the screen. The runnable action must be a class that inherits from the runnable class see \ref{sec:runnable}. The image data must be an array of bytes formatted as either RGB or RGBA pixels. As the image data is a contigous array, the function also requires the knowledge of it's width and height. In order to differentiate the difference between RGB and RGBA, the constructor also needs to know how many channels are in  the image data. 3 defines a RGB image and 4 defines a RGBA image. In order to neaten code, if the channels argument is ommitted the system will assume a RGB image is supplied. This will be programmaticallly safe, as if an RGBA image is supplied but the channels are 3, the framework will not read outside the array of the image. It will however display a corrupted looking image, so it is recommended to explicitly pass the number of channels inside the image. 
Note that the size of the image is the size of the area that responds to the users touch. If the areas were different sizes, image scaling would have to be performed, which will lead to high levels of distortion on the very low resolution images displayed.

\subsubsection{setPosition()}

This method allows the developer to move the location of the button. It takes two arguments, the x and y co-ordinates where the top left corner of t he button will sit. The co-ordinate system used is that of pixels available on the screen. By default the button will be placed at (0,0) which places the top left corner of the button at the top left corner of the screen.

\subsubsection{getX()}

This method returns the current x position of the top left corner of the button. It is mainly used to find out the location of the button on the screen, in order to avoid laying another button over the same space.

\subsubsection{getY()}

Performs the same function as getX(), except it returns the y co-ordinate in pixels.

\subsubsection{getWidth()}

Returns the width of the image in pixels. This is used to find out how wide the image is on the screen.

\subsubsection{getHeight()}

Performs the same function as getWidth(), except returns the height instead of the width.

\subsubsection{invertButton()}

This method inverts all the colours on the button. This is used in the base class when a button is pressed (see \ref{sec:base:butpress}). This method marks the button as inverted, and the next call to enqueueDraw() will draw the button with inverted colours. Calling this function a second time will restore the state to it's original condition.

\subsubsection{getRunnable()}

When the button object is created, it requires a runnable object to perform when the button is pressed. This method returns a pointer to that object so that it may be run, or inspected by the framework.

\subsection{Digitelement}

The digit element is a class that is repsonsible for displaying numbers to the screen. It is fully implemented in the framework, and does not need any methods to be implemented to be use-able. It renders white colour numbers from zero to nine, with a transparent surrounding so it is able to be overlaid on any image. Internally the digitelement is aware of the number that it has currently displaying and the new value it needs to display. It maintains this awareness in order to change only the information that differs from that present on the screen. This is done in order to maximize performance of the system. If a number, say zero, is displayed the system will not draw a zero over the top of it, it will skip to drawing the next digit.

One caveat of this element is that it records the current background when it is initialized. This snapshot is used to clear out the previous image data if it differs from the desired data. This is done to prevent the digits from being drawn on-top of each other continuously. This does make the digit element currently unsuitable for display over any moving image data, though moving image data is not used extensively in the interface.

The digitelement is highly configurable, allowing the developer to specify the position, size, integer places, decimal places and units to be displayed after the digit element. Common engineering units are defined in the image element, such as km/h, V and A. This allows relevant information to be laid out quickly. 
The class takes double length floating point values as an input, but will display the number according to the parameters specified during construction. This ensures the element has consistent sizing, as a change in the magnitude of the number will not cause it to shift about on the display. If decimal places is less than 1, the element will round the value to the nearest integer.

Finally the digitelement can also represent an error state. This is typically used when no information has been recieved, so the number to be displayed is undefined. In this situation displaying any number would be incorrect. As such the element will display a horizontal dash. This indicates that an error has been triggered, and their is no valid data to display. 

\subsubsection{getX()}

This method returns the current x position of the top left corner of the button. It is mainly used to find out the location of the button on the screen.

\subsubsection{getY()}

Performs the same function as getX(), except it returns the y co-ordinate in pixels.

\subsubsection{getWidth()}

Returns the width of the digitelement in  pixels. This will be the width of a individual digit element multiplied by the number of digits that are being displayed.

\subsubsection{getHeight()}

Returns the height of the digitelement. This is the same as the height of any individual number in the element, as they are all rendered at the same size.

\subsubsection{setValue()}

This function is used to set the value to be displayed on the digitelement. The new value will be displayed on the screen after a call to enqueueDraw().

\subsubsection{setError()}

This function is used to set or reset the error state. It will cause the digitelement to display a horizontal line instead of numbers. 

\subsection{Console Element}
\label{sec:consoleelement}

The console element is a generic text element that is used to display full width text to the screen. The main purpose of this element is to provide an easy way to see debugging information on the screen itself, without requiring any remote connections to the controller. This element takes any string and converts it to be correctly displayed on the screen. It is designed to be used with data that is dynamically changing.

The console element maintains an internal queue of the elements it is currently displayed. This allows a buffer to exist that will display the most recently added strings. The older strings will be removed as newer strings are added. To avoid any conflicts with memory, a string is copied into the internal buffer when it is added. This prevents any other section of the program from freeing or overwriting the memory where the string was stored. When a string is no longer being displayed, it is removed from the queue, and the memory used to store it is cleared.

As the queue has the possibility of being accessed from multiple threads, it must have security in place to ensure the queue does not become corrupted. If any strings memeory is cleared at the same it is being drawn, the system will have undefined behaviour. In order to prevent this, a mechanism calling locking is used. When a thread needs to manipulate or read the queue, it locks the queue. Any other thread that tries to lock the queue at this point will be forced to wait. When the thread is finally finished with the queue, it will unlock the queue, allowing the other thread to perform an operation on it. This will cause the second thread to stop until the first thread is finished. This simple method of synchronization will prevent the queue from becoming corrupt, and ensures the stability of the console element.

The console element is concerned with displaying the newest values first. In order to best illustrate this, the new values appear at the bottom of the screen, and move upwards until they are no longer displayed. This mimics the display of consoles in normal computers. 

A problem that can occur with the display of the strings is the string length. The display only has a fixed width, and the desired string may be longer than the screen width. This could cause some of the data to not appear on the screen. In order to alleviate this problem, the string is split into multiple strings, each with a maximum length that is equal to the width of the screen. This allows the string to be rendered on multiple lines. When a string spills over to multiple lines, it means less space for the older lines that are to be rendered. The element takes into account multi-line strings, and may not always display the desired amount of strings if some strings are too long. This is done to enable all of the information of the newer strings to be read.

A problem with multiple-lined strings is that it can be hard to differentiated between the different lines. To solve this the console element uses alternating colours when displaying different lines. This provides strong visual indicators as to which lines are grouped together as one string, making it easy to identify what the element is trying to say.

\subsubsection{consolelement()}

The constructor to the consoleelement takes two arguments. The first is an offset. This offset specifies how many lines at the top of the screen the element should not print in. This is to prevent the element from drawing text over buttons or other elements that may appear at the top of the screen. The second element is the maximum number of lines that should be drawn. This argument is used to prevent the element from drawing over buttons or other elements at the bottom of the screen.

\subsubsection{addLine()}

This method adds a line to the queue. It will lock the queue, add the line, free any lines that are now too old and then finally unlock the queue. Note that this makes it's own copy of the supplied string, so it's argument may be destroyed after this method is called.

\subsubsection{draw()}

This method is implemented in the console element and does not need to be overridden. It will lock the queue, split any multiple line strings, draw the lines and then unlock the queue. This method is called by the framework, if the developed wants to refresh the console element, enqueueDraw() should be called instead.

\subsection{UIImage}

Basic functionality that is useful to have in any graphical display is that of displaying images. This ability is faciliated by the image class. This is a simple class that allows an image to be displayed and placed anywhere on the display. The image class represents an image internally as an uncompressed byte array. This image is sent to the lower layers for display, and can have it's location manipulated by calling functions on the class.

The image class does not need to be extended to be utilized by the  developer. It is fully implemented inside the windowing toolkit. Once it has been instantiated it is able to display the image to the screen. The image class can accept either raw uncompressed byte data to display, or it can load up a PNG format image from the devices file-system. This flexibility was introduced in order to allow images not compiled with the executable to be displayed. This functionality is used in depth in the Map display panel of the user inter-face see section \ref{sec:maps}.

Image data that is loaded via a byte array will only be displayed by the image class. The memory used to store the image will not be cleared on destruction of the image object. This is done for stability reasons, as it is impossible to know if any other portion of the program is using this data, or if the data was statically compiled into the executable. If a filename is supplied, the image class will perform all the memory management functions. It will load the PNG image and convert it to the internal structure required by the lower level display drivers. It will also free the converted data when the image class is destroyed. As this is all done internally, the developer does not need to worry about memory management when using the image class. This was done to minimize memory leaks, as the class will always free internal data when it will no longer needed to be used.

\subsubsection{uiimage()}

Two constructors exist for the image class. The first constructor takes the position and image data as an argument. This constructor will set the internal pointers to the image data towards the supplied arguments. It will set up the image in a non memory managed mode. In this mode the image class will not free the image data when it is destroyed. This mode of operation is suited towards static image data that is compiled into the program. An example of this is images or icons that are used to display navigational or informational aids.

The other constructor for this class takes the filename of an image on the device's filesystem. If the file cannot be found, a substitute error message is used in it's place. This will cause something always to be displayed to the user inter-face on this images location. This mode will convert the supplied file from the PNG format to a contiguous array of bytes. When destroyed, the array of bytes will be cleared automatically. 


\subsubsection{setPosition()}

This method allows the developer to set the x and y position of the top left corner of the image.


