\section{Elements}

The windowing toolkit consists of pre-made classes that the are either used directly, such as the digit display element, or are inherited from, such as the base or runnable classes. Figure \ref{uiframework3} shows the classes developed in the toolkit.

\figuremacro{uiframework3}{UML diagram of the window toolkit}{}

\subsection{UIElement}

The UIElement is the most basic class definition in the toolkit. It is an abstract class that can never be instantiated. Its purpose is to define methods for interacting with the screen and other objects. It also provides default functionality for most methods, this allows all the classes that inherit from it to function the same way.

\subsubsection{addChild()}

An important definition of the UIElement class, is that it may contain any number of other UIElement classes inside it. To add another UIElement class the method addChild() is called. This stores the child element inside a C++ vector whose length is only limited by the amount of ram inside the machine. The advantage of this is that actions can be performed on a UIElement and all it's children. If a element needs to be drawn, all it's children will be drawn too or if an element is disabled, all it's children will be disabled too.

\subsubsection{draw()}

 The most important method of the UIElement class is the draw method.  This method definition is not implemented in the UIElement class, it is defined a virtual abstract method. All classes that can be instantiated must implement this function call. The purpose of this function call is to allow the user to specify the low level commands that are used to display this element. This can include drawing lines, squares, or setting individual pixels. This method should be implemented by the programmer, but should only ever be called by the mechanics of the toolkit. The developed of the user interface should never directly call this method.

\subsubsection{enqueueDraw()}

enqueueDraw() is called whenever the system, or the programmer, wants to trigger a refresh of the screen. This will signal the toolkit that a redraw should be prepared. The purpose of this method is two-fold. Firstly it allows the toolkit to perform optimizations of the draw function in order to maximize speed (see \ref{Redrawing the Screen}). Secondly it's implementation has O(1) complexity. This means that the call to enqueueDraw() completes in constant time. This is used for performance reasons, as whatever thread has called enqueueDraw(), will not need to wait for the screen to be redrawed, it will return instantly. The draw will be scheduled to occur some time after enqueueDraw() is called. By default this method will also call the enqueueDraw() method of all it's children, allowing entire sections of the display to be redrawn using one function call.

\subsubsection{animate()}
TODO

\subsubsection{setActive()}

A property that is required of any draw-able object inside the toolkit is whether it is current being displayed to the user. This property allows elements to exist in the machines memory, but only be draw if they are current being displayed. To manipulate this property, the method setActive() is called. This method allows the state to be set to either true or false, meaning that the object will be drawn or not drawn respectively. If the active state is false, calls to enqueueDraw() will be processed, but the call to the draw() function will be skipped. Thus individual elements of the display can be hidden at will. This method will also call the setActive() method of all the children of this element. Thus allowing sections of the display to be hidden with one function call.

\subsubsection{isActive()}

This method will return the current state of the element. This is used to check whether the current element is being drawn or not. This method is called internally by the screen drawing mechanics. It can also be used in order to check whether the element is being displayed, and perform different tasks if it is not being displayed.

\subsection{base}

The base element represents the panels or windows that are being displayed to the user. An important property of the base element is that it is defined to occupy the whole screen. This element will draw the entire width of the screen, which will clear any old draws that may still be present. Another extended property of the base element is that it maintains a list of all the other base elements that are present. This is used in order to allow for global navigation buttons. Rather than layout buttons in the same location on every screen, a button can be added as a global button. This will ensure that it appears on all the screens present in the list. This allows the buttons and their location on the screen to be defined once, making the final program more stable and simpler to understand.
For further discussion on the button element see \ref{Button}.
The base class itself is abstract, it cannot be instansiated. There is no way to display a "default" base element. In order to build a panel, the panel must inherit from the base element, and implement at minimum the abstract function getButton().

\subsubsection{base()}

The constructor for this class takes a single argument. This argument is a boolean value indiciating whether this panel will display global buttons or not. By default this option is set to true, though it can be easily overriden when a new class is inheriting from this one. This optional argument allows a panel to forego global buttons. This is used in the case when the developed only wishes to display a simpler panel, or when the current set of global buttons would appear in-appropriately on this panel.

\subsubsection{draw()}

This class implements a rudimentary version of the draw method. This specifies a default display for each fullscreen panel the user will view. The reasons for this functionality are two-fold. Firstly, it allows a common backdrop to be defined for each screen. This keeps a sense of consitency while navigating, as the background will always be similar. It is also useful in speeding up development, as having a default state for a panel is useful for prototyping and implementing new panels. The second reason a default is specified is to remove any elements that were present on the previous screen. Even though buttons and UIelements may not be active anymore, pixels may still be set corresponding to their images. These pixels may have last been refreshed a long time ago. They will remain in the framebuffer until they are overwritten by a new set of image data. As the a base panel is defined as occupying the whole screen, it will replace and UIElements that may already exist on the screen, thus removing them from being visible. As the instance of this base class with be enqueued onto the drawing queue first, all it's child elements will still be drawn correctly.

\subsubsection{getButton()}

In order to transition to a panel, an action must be undertaken by either the user or the system. The most common way of transisitioning would be when the user wants to display a different screen. Typically this would occur by the use of pressing buttons. This is why any base panel must implement the getButton() function. This function returns a button object that contains the image data to display for this button, and the action to undertake when the button is pressed. This action will typically be a call to the activate() function of the panel, though other actions can be called before the call to activate().

\subsubsection{addButton()}

A common element that will be placed on any panel is a button element. This is the basic way in which the user navigates. A button element itself is a child element of the panel it is contained in, it needs to be drawn when the panel is drawn. A button will also have extra functionality than just being drawn, namely, it can be pressed by the user. As the existing addChild() function only adds the element to the list of child elements to be drawn, an extra method was developed to add buttons to a panel. This method is the addButton method. This method adds the button element to the list of children, but also registers the button element as an interactable object. Internally this is achieved by adding the button to a list that contains only buttons. This list is ordered in the order that the buttons were added to the panel. Maintain this list is important in order to translate the lower level screen interactions into finding which button was pressed see \ref{button_thread}.

\subsubsection{addGlobalButton()}

Mentioned earlier was the use of global buttons, which are buttons that will appear on every class that inherits from base. In order to distinguish between buttons that are added to every base panel and buttons that are added only to the current base panel, the addGlobalButton() function was developed. This method is declared statically and does not need to be called on an instance of a base class, however it does need at least one instance to have been created for it's effects to be observable. In it's simplest form, this method iterates over the list of base elements, and calls the addButton() method on each base using the supplied button argument. This allows the same button to appear on multiple screens, due to the fact that it is the exact same object, it will perform the exact same action and be laid out in the exact same place on each screen.

\subsubsection{refreshTouchMap()}

This method is an internal method to the framework, and should not need to be called by the developer. It is responsible for setting up the touch screen in the lower level libraries. It takes the list of buttons that has been built by calling addButton() and registers each button and the region the button exists on with the touch drivers. This abstracts any interaction or understanding of how the touch screen mechanics away from the developer. This function will be called whenever activate is called, thus setting up the framework to respond to actions on the buttons that exist on the current panel. It will also clear the previously registered buttons, so they cannot be clicked while the system is displaying the new panel.

\subsubsection{buttonPressed()}

The buttonPressed() method defines what happens when the user presses a button. This method is implemented in the base class definition in a way that it should never need to be overwritten in any classes inheriting from the base class. This method takes the position in the list of buttons that is pressed and performs the actions that occur when the button is pressed. The runnable abstract class allows any action to be coded and run by this method see \ref{runnable}. This method also performs things like animating the buttons. In order to provide instant feedback to the user pressing a button, the framework will invert the colour of the button. After a short while, the button will turn back to it's previous state, and the buttons action will be performed. This small animation provides instant feedback that the user has pressed the button, and results in a much more enjoyable user experience. Delaying the action also has another advantage. By waiting a short time between running the action, which is usually the display of a different base panel, the framework is able to remove and duplicate keypresses that may occur. This prevents the user from pressing a button to transisition into a panel, and then immediately pressing a button in the new panel which they did not intend to press.

\subsubsection{activate()}

The activate method is defined in the base class. It can be overwritten in classes that inherit from the base class, though any class implementing different functionality should call the base classes activate() method as well. This method's main responsibility is to display or 'activate' the panel that it is called upon, and to translate the touch driver information into button presses. The default functionality of this method, is to call enqueueDraw() first. This will display the current panel on the screen. Next it will call refreshTouchMap(), to register the active buttons to the framework. Once the panel has been setup, this method will then block and await input from the user via screen events. Thus this method should only ever be called in the thread that is responsible for controlling the button presses. A apparent downside to this is that there is no easy to for the developer to change the active panel inside a different thread, it is certainly possible to change the active panel though it is more difficult than changing in response to user interaction. On the other hand, this limitation is actually advantageous from a user friendliness standpoint. As the screen will only change from different base panels in response to actions performed by the user, it is easier for them to mentally link actions they have performed into re-actions displayed by the device. This specification means that the panels won't transisition by themselves, leading to a much simpler and easier to understand user interface. 

This method also allows animations to be specified. By supplying an argument defining the type of screen transition to use, activate method will perform the actions necessary to animate the transisition between the previous panel and this one. These transisitions are implemented inside the screen driver, and include sliding the screen in and out. For performance reasons, the default transistion is an in-place swap, which is the most efficient in respect to CPU time.

When this method finishes it returns the next action to run. This could either be a class that runs the next panel, or some other action to be performed when this panel is not longer being displayed.

\subsection{runnable}

The runnable class is an abstract class which is used to allow the developer using the toolkit to run actions inside the toolkit. By using polymorphism, the toolkit is able to call methods on classes which were not programmed or compiled with the toolkit. This runnable aspect is used in order to 'run' various aspects of the user interface. For instance, the base class's activate function must return a pointer to a runnable class. This is used to define what happens when the panel is no longer active. Runnable classes are also used extensively by the button system. A button must contain a runnable class. This class will be run when the button is pressed. Thus allowing any code to run whenever a button is pressed by the user. 

\subsubsection{isScreenChange}

A property used in the runnable class is whether this action is triggering a screen change or not. This property is set to true by default. If this property is to, the previous base panel that called this action will have it's active property set to false. This suppresses the last screen from being changed, so the runnable action does not need to know where it was called from. If this property is set to false, the previous panel will not be flagged as inactive. This is used whenever an action is updating a element on the user interface, and does only wants to trigger a redraw of the element that changed. The previous panel will remain active, and will resume listening to touch events when the runnable action is finished.

\subsubsection{run()}

This is the abstract method that must be implemented in any class inheriting from the runnable class.
